{"version":3,"file":"newline-iterator.min.js","sources":["../../src/index.ts","../../node_modules/index-of-newline/dist/esm/index.mjs"],"sourcesContent":["import indexOfNewline from 'index-of-newline';\n\nconst hasIterator = typeof Symbol !== 'undefined' && Symbol.iterator;\n\n/**\n * Create a newline iterator recognizing CR, LF, and CRLF using the Symbol.iterator interface\n *\n * @param string The string to iterate through\n *\n * ```typescript\n * import newlineIterator from \"newline-iterator\";\n *\n * const iterator = newlineIterator(\"some\\r\\nstring\\ncombination\\r\");\n * const results = [];\n * for (const line of iterator) results.push(line);\n * console.log(results); // [\"some\", \"string\", \"combination\"];\n * ```\n */\nexport default function newlineIterator(string: string): IterableIterator<string> {\n  let offset = 0;\n  const iterator = {\n    next(): IteratorResult<string, boolean> {\n      if (offset >= string.length) return { value: undefined, done: true };\n      let [index, skip] = indexOfNewline(string, offset, true) as number[];\n      if (index < 0) {\n        index = string.length;\n        skip = 0;\n      }\n      const line = string.substr(offset, index - offset);\n      offset = index + skip;\n      return { value: line, done: false };\n    },\n  };\n\n  if (hasIterator) {\n    iterator[Symbol.iterator] = function (): Iterator<string> {\n      return this;\n    };\n  }\n\n  return iterator as IterableIterator<string>;\n}\n","/**\n * Find indexOf CR, LF, or CRLF\n *\n * @param string The search string\n * @param offset The offset for searching\n * @param includeLength Include the length in the return value\n * @returns When includeLength is true, returns a pair of [offset, length] to provide the length of CR (1), LF (1) or CRLF (2)\n */ export default function indexOfNewline(string, offset = 0, includeLength = false) {\n    if (offset < 0) throw new Error('Unexpected negative offset');\n    if (offset > string.length) throw new Error(`Offset is longer than the string. Offset: ${offset}. String: ${string.length}`);\n    while(offset < string.length){\n        const value = string[offset];\n        if (value === '\\n') return includeLength ? [\n            offset,\n            1\n        ] : offset;\n        else if (value === '\\r') {\n            return includeLength ? [\n                offset,\n                string[offset + 1] === '\\n' ? 2 : 1\n            ] : offset;\n        }\n        offset++;\n    }\n    return includeLength ? [\n        -1,\n        0\n    ] : -1;\n};\n"],"names":["_arrayLikeToArray","arr","len","hasIterator","Symbol","iterator","string","offset","next","length","value","undefined","done","indexOfNewline","arguments","includeLength","Error","concat","index","skip","line","substr","this"],"mappings":"gPAAA,SAAAA,EAAAC,EAAAC,+7BAEA,IAAMC,EAAgC,oBAAXC,QAA0BA,OAAOC,gBAgB7C,SAAyBC,GACtC,IAAIC,EAAS,EACPF,EAAW,CACfG,KAAAA,WACE,GAAID,GAAUD,EAAOG,OAAQ,MAAO,CAAEC,WAAOC,EAAWC,MAAM,GAC9D,IAAoBC,IChBP,SAAwBP,OAAQC,EAAAA,0CAASO,UAAA,GAAA,EAAGC,EAAAA,UAAqBN,OAAA,QAAA,IAAAK,UAAA,IAAAA,UAAA,GAChF,GAAIP,EAAS,EAAG,MAAM,IAAIS,MAAM,8BAChC,GAAIT,EAASD,EAAOG,OAAQ,MAAM,IAAIO,MAAO,6CAA+DV,OAAnBC,EAAO,cAA0BU,OAAdX,EAAOG,SACnH,KAAMF,EAASD,EAAOG,QAAO,CACzB,IAAMC,EAAQJ,EAAOC,GACrB,GAAc,OAAVG,EAAgB,OAAOK,EAAgB,CACvCR,EACC,GACDA,EACC,GAAc,OAAVG,EACL,OAAOK,EAAgB,CACnBR,EACuB,OAAvBD,EAAOC,EAAS,GAAc,EAAI,GAClCA,EAERA,IAEJ,OAAOQ,EAAgB,EAClB,EACA,IACA,EDJiBF,CAAeP,EAAQC,GAAQ,MAA9CW,EAAeL,EAAoC,GAA5CM,EAAQN,EAAoC,GACpDK,EAAQ,IACVA,EAAQZ,EAAOG,OACfU,EAAO,GAET,IAAMC,EAAOd,EAAOe,OAAOd,EAAQW,EAAQX,GAE3C,OADAA,EAASW,EAAQC,EACV,CAAET,MAAOU,EAAMR,MAAM,KAUhC,OANIT,IACFE,EAASD,OAAOC,UAAY,WAC1B,OAAOiB,OAIJjB"}